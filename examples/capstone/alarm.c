/*****************************************************************************
* Model: capstone.qm
* File:  ./alarm.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::alarm.c} ............................................................*/
#include "qpn_port.h"
#include "bsp.h"
#include "capstone.h"
#include "alarm.h"

#ifndef NDEBUG
Q_DEFINE_THIS_FILE
#endif

int getBitPosition(uint8_t b) {
    uint8_t i;

    for(i=7; i>=0;i--)
    {
        if(b & _BV(i))
            return i;
    }
    return -1;

}

/* Pelican class declaration -----------------------------------------------*/
/*${AOs::AlarmMgr} .........................................................*/
typedef struct AlarmMgr {
/* protected: */
    QMActive super;

/* private: */
    uint8_t curr_alarm;
    uint8_t active_alarms;
    uint8_t count;
} AlarmMgr;

/* protected: */
static QState AlarmMgr_initial(AlarmMgr * const me);
static QState AlarmMgr_on  (AlarmMgr * const me);
static QState AlarmMgr_on_i(AlarmMgr * const me);
static QMState const AlarmMgr_on_s = {
    (QMState const *)0, /* superstate (top) */
    Q_STATE_CAST(&AlarmMgr_on),
    Q_ACTION_CAST(0), /* no entry action */
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(&AlarmMgr_on_i)
};
static QState AlarmMgr_silent  (AlarmMgr * const me);
static QState AlarmMgr_silent_e(AlarmMgr * const me);
static QMState const AlarmMgr_silent_s = {
    &AlarmMgr_on_s, /* superstate */
    Q_STATE_CAST(&AlarmMgr_silent),
    Q_ACTION_CAST(&AlarmMgr_silent_e),
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState AlarmMgr_playing  (AlarmMgr * const me);
static QState AlarmMgr_playing_e(AlarmMgr * const me);
static QState AlarmMgr_playing_i(AlarmMgr * const me);
static QMState const AlarmMgr_playing_s = {
    &AlarmMgr_on_s, /* superstate */
    Q_STATE_CAST(&AlarmMgr_playing),
    Q_ACTION_CAST(&AlarmMgr_playing_e),
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(&AlarmMgr_playing_i)
};
static QState AlarmMgr_beep  (AlarmMgr * const me);
static QState AlarmMgr_beep_e(AlarmMgr * const me);
static QState AlarmMgr_beep_x(AlarmMgr * const me);
static QMState const AlarmMgr_beep_s = {
    &AlarmMgr_playing_s, /* superstate */
    Q_STATE_CAST(&AlarmMgr_beep),
    Q_ACTION_CAST(&AlarmMgr_beep_e),
    Q_ACTION_CAST(&AlarmMgr_beep_x),
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState AlarmMgr_off  (AlarmMgr * const me);
static QState AlarmMgr_off_e(AlarmMgr * const me);
static QState AlarmMgr_off_x(AlarmMgr * const me);
static QMState const AlarmMgr_off_s = {
    &AlarmMgr_playing_s, /* superstate */
    Q_STATE_CAST(&AlarmMgr_off),
    Q_ACTION_CAST(&AlarmMgr_off_e),
    Q_ACTION_CAST(&AlarmMgr_off_x),
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState AlarmMgr_long_off  (AlarmMgr * const me);
static QState AlarmMgr_long_off_e(AlarmMgr * const me);
static QState AlarmMgr_long_off_x(AlarmMgr * const me);
static QMState const AlarmMgr_long_off_s = {
    &AlarmMgr_playing_s, /* superstate */
    Q_STATE_CAST(&AlarmMgr_long_off),
    Q_ACTION_CAST(&AlarmMgr_long_off_e),
    Q_ACTION_CAST(&AlarmMgr_long_off_x),
    Q_ACTION_CAST(0)  /* no intitial tran. */
};


/* Global objects ----------------------------------------------------------*/
AlarmMgr AO_AlarmMgr;

/* Capstone class definition -----------------------------------------------*/
/*${AOs::AlarmMgr_ctor} ....................................................*/
void AlarmMgr_ctor(void) {
    QMActive_ctor(&AO_AlarmMgr.super, Q_STATE_CAST(&AlarmMgr_initial));
}
/*${AOs::AlarmMgr} .........................................................*/
/*${AOs::AlarmMgr::SM} .....................................................*/
static QState AlarmMgr_initial(AlarmMgr * const me) {
    static struct {
        QMState const *target;
        QActionHandler act[2];
    } const tatbl_ = { /* transition-action table */
        &AlarmMgr_on_s, /* target state */
        {
            Q_ACTION_CAST(&AlarmMgr_on_i), /* init.tran. */
            Q_ACTION_CAST(0) /* zero terminator */
        }
    };
    /* ${AOs::AlarmMgr::SM::initial} */
    return QM_TRAN_INIT(&tatbl_);
}
/*${AOs::AlarmMgr::SM::on} .................................................*/
/* ${AOs::AlarmMgr::SM::on::initial} */
static QState AlarmMgr_on_i(AlarmMgr * const me) {
    static struct {
        QMState const *target;
        QActionHandler act[2];
    } const tatbl_ = { /* transition-action table */
        &AlarmMgr_silent_s, /* target state */
        {
            Q_ACTION_CAST(&AlarmMgr_silent_e), /* entry */
            Q_ACTION_CAST(0) /* zero terminator */
        }
    };
    /* ${AOs::AlarmMgr::SM::on::initial} */
    return QM_TRAN_INIT(&tatbl_);
}
/* ${AOs::AlarmMgr::SM::on} */
static QState AlarmMgr_on(AlarmMgr * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::AlarmMgr::SM::on::ALARM_REQUEST} */
        case ALARM_REQUEST_SIG: {
            uint8_t alarm_type = (uint8_t)Q_PAR(me);
            /* ${AOs::AlarmMgr::SM::on::ALARM_REQUEST::[me->active_alar~} */
            if (me->active_alarms & _BV(alarm_type)) {
                status_ = QM_HANDLED();
            }
            /* ${AOs::AlarmMgr::SM::on::ALARM_REQUEST::[else]} */
            else {
                static struct {
                    QMState const *target;
                    QActionHandler act[3];
                } const tatbl_ = { /* transition-action table */
                    &AlarmMgr_playing_s, /* target state */
                    {
                        Q_ACTION_CAST(&AlarmMgr_playing_e), /* entry */
                        Q_ACTION_CAST(&AlarmMgr_playing_i), /* init.tran. */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                me->active_alarms |= _BV(alarm_type);
                me->curr_alarm = getBitPosition(me->active_alarms);
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        /* ${AOs::AlarmMgr::SM::on::ALARM_SILENCE} */
        case ALARM_SILENCE_SIG: {
            uint8_t alarm_type = (uint8_t)Q_PAR(me);
            /* ${AOs::AlarmMgr::SM::on::ALARM_SILENCE::[alarm_type==ALL~} */
            if (alarm_type == ALL_ALARMS) {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &AlarmMgr_silent_s, /* target state */
                    {
                        Q_ACTION_CAST(&AlarmMgr_silent_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                me->active_alarms = 0;
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::AlarmMgr::SM::on::ALARM_SILENCE::[else]} */
            else {
                me->active_alarms &= ~_BV(alarm_type);
                /* ${AOs::AlarmMgr::SM::on::ALARM_SILENCE::[else]::[me->active_alar~} */
                if (me->active_alarms == 0) {
                    static struct {
                        QMState const *target;
                        QActionHandler act[2];
                    } const tatbl_ = { /* transition-action table */
                        &AlarmMgr_silent_s, /* target state */
                        {
                            Q_ACTION_CAST(&AlarmMgr_silent_e), /* entry */
                            Q_ACTION_CAST(0) /* zero terminator */
                        }
                    };
                    status_ = QM_TRAN(&tatbl_);
                }
                /* ${AOs::AlarmMgr::SM::on::ALARM_SILENCE::[else]::[else]} */
                else {
                    alarm_type = getBitPosition(me->active_alarms);
                    /* ${AOs::AlarmMgr::SM::on::ALARM_SILENCE::[else]::[else]::[me->curr_alarm!~} */
                    if (me->curr_alarm != alarm_type) {
                        static struct {
                            QMState const *target;
                            QActionHandler act[3];
                        } const tatbl_ = { /* transition-action table */
                            &AlarmMgr_playing_s, /* target state */
                            {
                                Q_ACTION_CAST(&AlarmMgr_playing_e), /* entry */
                                Q_ACTION_CAST(&AlarmMgr_playing_i), /* init.tran. */
                                Q_ACTION_CAST(0) /* zero terminator */
                            }
                        };
                        me->curr_alarm = alarm_type;
                        status_ = QM_TRAN(&tatbl_);
                    }
                    /* ${AOs::AlarmMgr::SM::on::ALARM_SILENCE::[else]::[else]::[else]} */
                    else {
                        status_ = QM_HANDLED();
                    }
                }
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::AlarmMgr::SM::on::silent} .........................................*/
/* ${AOs::AlarmMgr::SM::on::silent} */
static QState AlarmMgr_silent_e(AlarmMgr * const me) {
    BSP_ledOff(BUZZER);
    me->curr_alarm = 0;
    me->active_alarms = 0;
    return QM_ENTRY(&AlarmMgr_silent_s);
}
/* ${AOs::AlarmMgr::SM::on::silent} */
static QState AlarmMgr_silent(AlarmMgr * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; /* avoid compiler warning in case 'me' is not used */
    return status_;
}
/*${AOs::AlarmMgr::SM::on::playing} ........................................*/
/* ${AOs::AlarmMgr::SM::on::playing} */
static QState AlarmMgr_playing_e(AlarmMgr * const me) {
    me->count = 0;
    return QM_ENTRY(&AlarmMgr_playing_s);
}
/* ${AOs::AlarmMgr::SM::on::playing::initial} */
static QState AlarmMgr_playing_i(AlarmMgr * const me) {
    static struct {
        QMState const *target;
        QActionHandler act[2];
    } const tatbl_ = { /* transition-action table */
        &AlarmMgr_beep_s, /* target state */
        {
            Q_ACTION_CAST(&AlarmMgr_beep_e), /* entry */
            Q_ACTION_CAST(0) /* zero terminator */
        }
    };
    /* ${AOs::AlarmMgr::SM::on::playing::initial} */
    return QM_TRAN_INIT(&tatbl_);
}
/* ${AOs::AlarmMgr::SM::on::playing} */
static QState AlarmMgr_playing(AlarmMgr * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; /* avoid compiler warning in case 'me' is not used */
    return status_;
}
/*${AOs::AlarmMgr::SM::on::playing::beep} ..................................*/
/* ${AOs::AlarmMgr::SM::on::playing::beep} */
static QState AlarmMgr_beep_e(AlarmMgr * const me) {
    BSP_ledOn(BUZZER);
    QActive_arm((QActive *)me, SHORT_PULSE);
    return QM_ENTRY(&AlarmMgr_beep_s);
}
/* ${AOs::AlarmMgr::SM::on::playing::beep} */
static QState AlarmMgr_beep_x(AlarmMgr * const me) {
    QActive_disarm((QActive *)me);
    return QM_EXIT(&AlarmMgr_beep_s);
}
/* ${AOs::AlarmMgr::SM::on::playing::beep} */
static QState AlarmMgr_beep(AlarmMgr * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::AlarmMgr::SM::on::playing::beep::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            ++me->count;
            /* ${AOs::AlarmMgr::SM::on::playing::beep::Q_TIMEOUT::[me->count==me->~} */
            if (me->count == me->curr_alarm) {
                static struct {
                    QMState const *target;
                    QActionHandler act[3];
                } const tatbl_ = { /* transition-action table */
                    &AlarmMgr_long_off_s, /* target state */
                    {
                        Q_ACTION_CAST(&AlarmMgr_beep_x), /* exit */
                        Q_ACTION_CAST(&AlarmMgr_long_off_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::AlarmMgr::SM::on::playing::beep::Q_TIMEOUT::[else]} */
            else {
                static struct {
                    QMState const *target;
                    QActionHandler act[3];
                } const tatbl_ = { /* transition-action table */
                    &AlarmMgr_off_s, /* target state */
                    {
                        Q_ACTION_CAST(&AlarmMgr_beep_x), /* exit */
                        Q_ACTION_CAST(&AlarmMgr_off_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::AlarmMgr::SM::on::playing::off} ...................................*/
/* ${AOs::AlarmMgr::SM::on::playing::off} */
static QState AlarmMgr_off_e(AlarmMgr * const me) {
    BSP_ledOff(BUZZER);
    QActive_arm((QActive *)me, SHORT_PULSE);
    return QM_ENTRY(&AlarmMgr_off_s);
}
/* ${AOs::AlarmMgr::SM::on::playing::off} */
static QState AlarmMgr_off_x(AlarmMgr * const me) {
    QActive_disarm((QActive *)me);
    return QM_EXIT(&AlarmMgr_off_s);
}
/* ${AOs::AlarmMgr::SM::on::playing::off} */
static QState AlarmMgr_off(AlarmMgr * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::AlarmMgr::SM::on::playing::off::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            static struct {
                QMState const *target;
                QActionHandler act[3];
            } const tatbl_ = { /* transition-action table */
                &AlarmMgr_beep_s, /* target state */
                {
                    Q_ACTION_CAST(&AlarmMgr_off_x), /* exit */
                    Q_ACTION_CAST(&AlarmMgr_beep_e), /* entry */
                    Q_ACTION_CAST(0) /* zero terminator */
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::AlarmMgr::SM::on::playing::long_off} ..............................*/
/* ${AOs::AlarmMgr::SM::on::playing::long_off} */
static QState AlarmMgr_long_off_e(AlarmMgr * const me) {
    BSP_ledOff(BUZZER);
    QActive_arm((QActive *)me, LONG_PULSE);
    return QM_ENTRY(&AlarmMgr_long_off_s);
}
/* ${AOs::AlarmMgr::SM::on::playing::long_off} */
static QState AlarmMgr_long_off_x(AlarmMgr * const me) {
    QActive_disarm((QActive *)me);
    return QM_EXIT(&AlarmMgr_long_off_s);
}
/* ${AOs::AlarmMgr::SM::on::playing::long_off} */
static QState AlarmMgr_long_off(AlarmMgr * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::AlarmMgr::SM::on::playing::long_off::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            static struct {
                QMState const *target;
                QActionHandler act[3];
            } const tatbl_ = { /* transition-action table */
                &AlarmMgr_beep_s, /* target state */
                {
                    Q_ACTION_CAST(&AlarmMgr_long_off_x), /* exit */
                    Q_ACTION_CAST(&AlarmMgr_beep_e), /* entry */
                    Q_ACTION_CAST(0) /* zero terminator */
                }
            };
            me->count = 0;
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}

